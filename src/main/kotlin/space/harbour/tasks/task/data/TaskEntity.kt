package space.harbour.tasks.task.data

import jakarta.persistence.*
import space.harbour.tasks.task.domain.TaskStatus

/**
 * JPA Entity for persisting tasks in the database.
 *
 * IMPORTANT: We use a regular class (not data class) for JPA entities because:
 * 1. Data class generates equals/hashCode using all properties, which can cause issues
 *    with lazy loading (accessing lazy properties in equals triggers database queries)
 * 2. Data class toString() can cause infinite recursion with bidirectional relationships
 * 3. For simple entities like this, data class works, but it's better to learn the correct pattern
 *
 * For students: In production code, always use regular classes for @Entity
 */
@Entity
@Table(name = "tasks")
class TaskEntity(
    /**
     * Primary key - auto-generated by the database.
     * Nullable because new entities don't have an ID yet (assigned on save).
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    /**
     * Task description - what needs to be done.
     * Using 'var' (mutable) because JPA needs to modify this for updates.
     * length=1000: limits description to 1000 characters in the database
     * nullable=false: enforces NOT NULL constraint at database level
     */
    @Column(length = 1000, nullable = false)
    var description: String,

    /**
     * Current status of the task (NEW, IN_PROGRESS, COMPLETED, REJECTED).
     * @Enumerated(EnumType.STRING) stores the enum name ("NEW") instead of ordinal (0)
     * This makes the database more readable and safer when enum order changes.
     */
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var status: TaskStatus
) {
    /**
     * Override equals for JPA entities.
     *
     * For students: This handles three cases:
     * 1. Same object reference → always equal
     * 2. Both persisted (have IDs) → compare by ID only
     * 3. Both new (no IDs) → compare by fields (for testing)
     * 4. One persisted, one new → not equal
     *
     * Why not just use data class equals?
     * - JPA entities should use ID-based equality when persisted
     * - Comparing all fields can trigger lazy loading issues
     * - This pattern is JPA best practice
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is TaskEntity) return false

        // Both persisted (have IDs) - compare by ID
        if (id != null && other.id != null) {
            return id == other.id
        }

        // Both new (no IDs) - compare by fields (useful for tests)
        if (id == null && other.id == null) {
            return description == other.description && status == other.status
        }

        // One persisted, one new - not equal
        return false
    }

    /**
     * Override hashCode based only on ID.
     * Must be consistent with equals() - same ID should have same hashCode.
     * For new entities (id=null), use class hashCode to ensure consistency.
     */
    override fun hashCode(): Int {
        return id?.hashCode() ?: javaClass.hashCode()
    }

    /**
     * Override toString to avoid potential issues with lazy loading.
     * Only includes essential fields, not relationships (if we add them later).
     */
    override fun toString(): String {
        return "TaskEntity(id=$id, description='$description', status=$status)"
    }
}
