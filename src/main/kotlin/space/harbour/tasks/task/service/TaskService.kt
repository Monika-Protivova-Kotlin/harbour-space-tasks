package space.harbour.tasks.task.service

import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import space.harbour.tasks.task.domain.Task
import space.harbour.tasks.task.domain.TaskStatus
import space.harbour.tasks.task.exception.InvalidTaskException
import space.harbour.tasks.task.exception.TaskNotFoundException
import space.harbour.tasks.task.exception.TaskOperationException
import space.harbour.tasks.task.persistence.TaskEntity
import space.harbour.tasks.task.repository.TaskRepository
import space.harbour.tasks.task.service.mapper.toDomain

/**
 * Service layer for Task business logic.
 *
 * This is the heart of the application where business logic lives:
 * 1. Validates input data (e.g., description not blank)
 * 2. Enforces business rules
 * 3. Coordinates between repositories and other services
 * 4. Handles transactions
 * 5. Throws domain-specific exceptions
 *
 * IMPORTANT ARCHITECTURAL PRINCIPLE: Business logic belongs HERE, not in controllers!
 *
 * Why separate Controller and Service?
 * - Controller: HTTP concerns (status codes, request/response format)
 * - Service: Business logic (validation, rules, orchestration)
 * - Repository: Database access (queries, persistence)
 *
 * Benefits:
 * - Business logic can be reused from different controllers or scheduled jobs
 * - Business logic can be tested without HTTP/Spring MVC
 * - Changes to HTTP layer don't affect business logic
 *
 * @Service: Marks this as a Spring service component
 *   - Spring creates and manages a single instance (singleton)
 *   - Can be injected into controllers and other services
 */
@Service
class TaskService(
    /**
     * Repository for database access.
     * Injected by Spring using constructor injection (recommended).
     */
    private val taskRepository: TaskRepository,
) {
    /**
     * Retrieve all tasks from the database.
     *
     * Note: This is a READ operation, so NO @Transactional needed.
     * Transactions are for write operations (create/update/delete).
     *
     * Exception handling pattern:
     * - Catch infrastructure exceptions (database errors)
     * - Convert to domain exceptions (TaskOperationException)
     * - Controller/client doesn't need to know about database internals
     *
     * @return List of all tasks as domain objects
     * @throws TaskOperationException if database operation fails
     */
    fun getTasks(): List<Task> {
        return try {
            // findAll() returns List<TaskEntity> from database
            // map { it.toDomain() } converts each TaskEntity to Task (domain model)
            taskRepository.findAll().map { it.toDomain() }
        } catch (ex: Exception) {
            // Wrap database exceptions in domain exception
            // This keeps the controller layer clean and domain-focused
            throw TaskOperationException("Failed to retrieve tasks", ex)
        }
    }

    /**
     * Retrieve a single task by ID.
     *
     * @param id The task ID to find
     * @return The task domain object
     * @throws TaskNotFoundException if task doesn't exist
     */
    fun getTask(id: Long): Task {
        return taskRepository.findById(id)
            .map { it.toDomain() }  // Convert TaskEntity to Task if found
            .orElseThrow { TaskNotFoundException(id) }  // Throw if not found
    }

    /**
     * Create a new task.
     *
     * Business logic:
     * 1. Validate description is not blank
     * 2. Create entity with default status (NEW)
     * 3. Save to database
     * 4. Return domain object
     *
     * @Transactional: Wraps this method in a database transaction
     *   - If method completes successfully → commit transaction
     *   - If exception thrown → rollback transaction
     *   - Ensures data consistency
     *
     * For students: When to use @Transactional?
     * - Any method that modifies data (insert/update/delete)
     * - Methods that need multiple operations to be atomic
     * - NOT needed for read-only operations (findAll, findById)
     *
     * @param description The task description
     * @return The created task
     * @throws InvalidTaskException if validation fails
     * @throws TaskOperationException if database operation fails
     */
    @Transactional
    fun addTask(description: String): Task {
        // VALIDATION: Business rule enforced here, not in controller
        // This ensures the rule is enforced regardless of how the method is called
        if (description.isBlank()) {
            throw InvalidTaskException("Task description cannot be blank")
        }

        return try {
            // Create new entity (id is null, will be generated by database)
            val newTask = TaskEntity(
                description = description,
                status = TaskStatus.NEW  // Default status for new tasks
            )
            // Save to database (JPA generates ID and returns saved entity)
            val savedTask = taskRepository.save(newTask)
            // Convert entity back to domain object for return
            savedTask.toDomain()
        } catch (ex: InvalidTaskException) {
            // Re-throw validation exceptions (don't wrap them)
            throw ex
        } catch (ex: Exception) {
            // Wrap infrastructure exceptions
            throw TaskOperationException("Failed to create task", ex)
        }
    }

    /**
     * Update an existing task.
     *
     * Business logic:
     * 1. Validate updated description is not blank
     * 2. Find existing task (throw if not found)
     * 3. Update fields
     * 4. Save changes
     * 5. Return updated domain object
     *
     * @Transactional: Critical here!
     *   - Ensures find + update happens atomically
     *   - If another request modifies the task between find and save,
     *     transaction ensures consistency
     *
     * @param id The task ID to update
     * @param updatedTask The new task data
     * @return The updated task
     * @throws TaskNotFoundException if task doesn't exist
     * @throws InvalidTaskException if validation fails
     * @throws TaskOperationException if database operation fails
     */
    @Transactional
    fun updateTask(id: Long, updatedTask: Task): Task {
        // VALIDATION: Enforce business rules
        if (updatedTask.description.isBlank()) {
            throw InvalidTaskException("Task description cannot be blank")
        }

        // Find existing task (throws TaskNotFoundException if not found)
        val existingTask = taskRepository.findById(id)
            .orElseThrow { TaskNotFoundException(id) }

        return try {
            // Update mutable fields
            // Note: We modify the existing entity, not create a new one
            // JPA tracks these changes and updates the database on commit
            existingTask.description = updatedTask.description
            existingTask.status = updatedTask.status

            // Save changes (JPA UPDATE query)
            val savedTask = taskRepository.save(existingTask)
            savedTask.toDomain()
        } catch (ex: InvalidTaskException) {
            throw ex
        } catch (ex: Exception) {
            throw TaskOperationException("Failed to update task with id $id", ex)
        }
    }

    /**
     * Delete a task by ID.
     *
     * Business logic:
     * 1. Check if task exists
     * 2. Delete it
     *
     * Note: Not @Transactional because deleteById is a single atomic operation.
     * But in real applications, you might want @Transactional if deletion
     * affects multiple tables (e.g., cascading deletes).
     *
     * @param id The task ID to delete
     * @throws TaskNotFoundException if task doesn't exist
     * @throws TaskOperationException if database operation fails
     */
    fun deleteTask(id: Long) {
        // Check existence first (better error message than DAO exception)
        if (!taskRepository.existsById(id)) {
            throw TaskNotFoundException(id)
        }

        try {
            taskRepository.deleteById(id)
        } catch (ex: Exception) {
            throw TaskOperationException("Failed to delete task with id $id", ex)
        }
    }
}
